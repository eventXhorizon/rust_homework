## 所有权

所有权就是变量的所有者对变量独占的拥有权。 基本规则： Rust 中的每一个值都有一个被称为其所有者 （ owner ）的变量。 值有且只有一个所有者。 当所有者（变量）离开作用域，这个值将被丢弃。

```rust
fn main() {
    let a: u32 = 8;
    let b: String = String::from("hello");
    let c: Vec<u8> = vec![1, 2, 3];
}
```

a就是`8`的所有者，`b`是`String::from("hello")`的所有者，`c`则是`vec![1, 2, 3]`的所有者。

`b`是`String::from("hello")`的所有者，但是`b`不是字符串`"hello"`的所有者。同理，`c`是`vec![1, 2, 3]`的所有者，但不是`[1, 2, 3]`的所有者。

对于整数类型，浮点数类型，布尔类型，字符类型，元组（当且仅当其包含的类型也都是`Copy`，如`(i32, i32)`），数组（当且仅当其包含的类型也都是`Copy`，如`[i32; 5]`），共享指针类型或共享引用类型，默认实现了 Copy，其他都是 Move。

所有权带有值和类型的信息，一个引用型变量也带有值和类型的信息，否则无法正确回溯到最终的值。



## 引用

Rust中的引用(references) 允许使用值但不获取其所有权，这种操作也被称为所有权借用（borrowing）。 通过 ＆T 和 ＆mut T 将引用分为两种： 不可变引用 （ &T ），也被称为共享引用，所有者可以读取引用指向的数据，但不能修改数据。 可变引用 （ &mut T ）也被称为独占引用，不能有别名，在同一时刻，同一个值不可能存在别的引用。

```rust
// 可以正常编译
let mut a = 10;
let b = &mut a;

*b = 20;

let c = &a;
```



```rust
// 编译报错
let mut a = 10;
let b = &mut a;

let c = &a;

*b = 20;
```

原因：在老版本编译器（Rust 1.31 之前）中，引用的作用域和变量的作用域一样，也是从定义的位置开始到花括号之前结束。正常编译的代码，在` *b = 20` 的时候，已经结束对 `a` 的 `mut` 引用，所以下面可以重新让 `c` 指向不变量引用 `&a` 。

所有权变量的作用域是从它定义到花括号结束。引用的作用域是从它定义到它最后一次使用结束。

总结：一个资源的可变引用与不可变引用的作用域不能交叠，即不能同时存在。



```rust
fn main() {
    let mut s1 = String::from("hello ");
    println!("{s1}");
    foo(&mut s1);
    println!("{s1}");		// 可变引用在 foo 函数弹出时被销毁，这里可以使用不可变引用了
}

fn foo(s :&mut String) {
    s.push_str("world");
}
```